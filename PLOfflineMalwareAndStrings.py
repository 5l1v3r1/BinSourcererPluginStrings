#!/usr/bin/env python
# -*-coding: utf8 -*-

########################################################################
# Copyright 2014 Concordia University
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific language
# governing permissions and limitations under the License.
########################################################################
# This Python script is part of BinSourcerer, a framework
# for assembly to source code matching
#
# Status: Debug
#
########################################################################



#-----------------------------------------------------------------------
# Configuration agent
# The two next function are needed so the configuration manager will be
# able to provide configuration for this module.
# configurationNeed is called first. If no config for this 
# utility exists, user is prompted for utility configuration. If
# configuration exists, previous configs will be used. In all cases,
# configuration step is ended when configurationProvision
# is called with a configuration list as arg.
#-----------------------------------------------------------------------
def configurationNeed():
    return None #This utility does not need configuration
            
def configurationProvision(utilityConfig=[]):
    pass #This utility does not need configuration

#----------------------------------------------------------------------
# Plugin type
# Since many plugins with diferent capabilities can be integrated
# to the framework, we need a general method to understand the
# use of each plugin in a unified way. The value returned by this method
# will allow the framework to call the right operations on the plugin.
# for more information about plugin types, see related comment inside
# BSPluginManager.py
#----------------------------------------------------------------------
def identifyPluginType():
    return ["analyser"] 
    
#-----------------------------------------------------------------------
# Plugin name
# This is used so the framework can give a name to a specific plugin
# The name will be used to visualy identify each plugins.
#-----------------------------------------------------------------------
def identifyPlugin():
    return ["OfflineMalwareAndStrings", "Malware and Strings"] #First item in list have to have the same name as main class name. Second item in list is visual name
       
#-----------------------------------------------------------------------
# OfflineMalwareAndStrings
# This class implements offline malware and String analysis capabilities
# This should be used with OfflineMalwareAndApianalyser
#-----------------------------------------------------------------------
class OfflineMalwareAndStrings():

	__repSTR = """<b>Strings: </b> %s <br />"""

	def __init__(self, plMngr):
		self._manager = plMngr


	def pluginAnalyse(self, analyseList):
		htmlString = ""
		#displays strings in fucntion
		offlineB = self.offlineStrings(analyseList)
		if(offlineB):
			htmlString += (self.__repSTR% offlineB)
		return htmlString

	def offlineStrings(self, felist): #add a flag here to return a list and to save comments
		im=[]
		res1=""
		for ft in felist:
			if 's' in ft:
				im.append(ft[1])
		for string in im:
			res1 += string
			res1 += "<br/>"
				
		return res1
     
#-----------------------------------------------------------------------
# __main__
# QA main for this module
#-----------------------------------------------------------------------
if __name__ == "__main__":

    x = OfflineMalwareAndStrings(None)


   
